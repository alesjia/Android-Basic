# 处理生命周期感知组件的生命周期
生命周期感知组件可以帮助你生产出更好组织，轻量以及更容易维护的代码
### 1.生命周期
lifeCycle是一个类，这个类持有一个组件（activity或fragment）的生命周期状态，并且允许其他对象来观察这个状态。
lifeCycle使用2个enum来跟踪它相关的组件的生命周期状态，Event和State
### 2.LifeCycleOwner
生命周期所有者，如activity或者fragment需要实现这个接口
对于生命周期的使用者，则需要实现LifecycleObserver这个接口，从而可以将这个观察者注册给生命周期的所有者
生命周期的观察者此时就是生命周期感知的，所以它可以在自己的内部处理生命周期操作。这样在使用这么生命周期感知组件的时候，只要初始化它就行，我们不需要处理生命周期的逻辑，所以activity和fragment相对来说更加简单了。
### 3.生命周期可知组件的最佳实践
* 保持UI控件越简单越好
* 使用数据驱动UI，UI控件的主要目的是在数据变化时更新界面，或者将用户的操作反馈给ViewModel
* 将数据逻辑都放在ViewModel类中。ViewModel是UI控件和其他部件的连接器
* 使用数据绑定来维护一个清晰的View和UI控件之间接口，
* 如果UI比较复杂，那么使用一个Presenter来处理UI的变化
* 避免在ViewModel中引用View或者Activity，否则会导致内存泄漏
### 4.生命周期可知组件的使用场景

## LiveData
* LiveData是一个类，它持有可观察数据。跟普通的可观察数据不同的是，LiveData是生命周期相关的。这就保证了只有在UI控件处于活跃状态才会去更新他们的UI。
* 所有注册的观察者，只有处于活跃状态的才会被通知。
### 使用LiveData的好处
* 可以保证你的数据和你的UI是一致的，也就是说只要数据有变化，那么观察者就会自动更新自己的UI
* 没有内存泄漏
* activity停止的时候不会导致崩溃
* 不用去手动处理生命周期
* 展示最新的数据
* 正确的配置变化处理
* 共享资源
### 如何使用LiveData对象
* 创建一个LiveData对象，一般都是在ViewModel中创建它
* 创建一个Observer对象，一般在activity或者fragment中创建它
* 使用observe方法将observer和LiveData绑定起来
* 当你更新存储在LiveData的值时，所有注册的观察者，只要是处于活跃状态的，都会被通知去更新UI
* 为何要将LiveData对象存储在ViewModel对象中，而不是activity或者fragment中，原因有二：一、避免activity或者fragment越来越大，这样UI控件主要职责是显式数据而不是管理数据状态。二、将LiveData的实例和activity或者fragment解藕，这样就可以保证LiveData在配置变化时存活。
### 扩展LiveData
### 转化LiveData
### 将多个LiveData的数据源合并
## Data Binding库
### 1.概览
安卓架构组件是Android JetPack的一部分，它是一个库集合，使用它可以开发出鲁棒的，可测试的以及可维护的应用。
* 更加方便的管理应用生命周期，新的生命周期可知组件帮助你管理你的activity和fragment的生命周期。配置变化时的数据可以持续保持，防止内存泄漏以及很方便的加载数据到UI中
* 使用LiveData来构建数据对象，数据变化时可以自动的更新View
* ViewModel可以在应用转屏的时候不销毁数据
* Room时一个Sqlite的数据库管理库
### 2.开始
### 3.布局和绑定表达式
### 4.使用Observable数据对象
### 5.生成绑定类
* 通过数据绑定库来生成绑定类，通过这个绑定类可以访问布局文件中的变量和视图
* 绑定类的名字以及包名可以定制化，绑定类都继承自ViewDataBinding类
* 每个布局文件生成一个对应的绑定类。默认情况下绑定类名是根据布局文件名来的。这个类持有所有布局属性以及布局视图之间的绑定。
#### 5.1 创建一个绑定对象
* 数据绑定库会根据定义在布局文件中的视图id来生成绑定类的可变化的成员
* 变量：根据定义在布局文件中的变量生成setter和getter
* ViewStub，如果需要加载另一个布局文件，则需要建立viewStub和新的布局文件之间的绑定
* 立即绑定
* 高级绑定
#### 5.2 绑定适配器
设置属性值
* 自动选择方法
* 指定自定义方法名称
* 提供自定义逻辑
对象变化
对象自动转化
自定义对象转化
#### 5.3 将架构组件和布局视图进行绑定
使用liveData来通知UI进行更新
使用ViewModel来管理UI相关的数据
使用可以观察的VIewModel
#### 5.4双向绑定
### 6.使用WorkManager来安排任务
WorkManager主要用来运行这种任务，即使在应用退出时，该任务也需要保证运行完毕。比如将应用数据上传到服务器中。如果一个任务需要在应用退出时被安全的关闭，那么推荐使用ThreadPools。
#### 6.1 WorkManager基础
类和概念
Worker：用来指定需要执行的任务
WorkRequest：包括需要执行的任务以及执行任务的条件，以及一个自动生成的work id。你可以使用这个id来取消一个任务或者获取一个任务状态。你可以直接使用OneTimeWorkRequest或者PeriodWorkRequest。
WorkManager：管理工作请求，将工作进行排队
WorkStatus：包括一个任务的基本信息，它是一个LiveData。
#### 6.2 WorkManager的高级使用
将多个任务按照顺序执行
启动一个工作序列，这个工作序列有一个名字，并且这个名字是唯一的。
如果你创建了一个新的工作序列，并且这个工作序列的名字跟已经运行的工作队列相同，那么你可以指定该如何与这个存在的队列进行合作。
* 比如取消现在运行的工作队列，然后运行这个新的工作队列
* 继续运行已经存在的工作队列，忽略这个新的工作队列
* 将这个新的工作队列添加到已经运行到工作队列后面
#### 6.3输入参数和返回值
### 7.ViewModel概览
ViewModel类是设计用作保存和管理UI相关的数据的，ViewModel可以保证在屏幕旋转的时候数据一直有效。
Android的框架会根据用户的行为或者设备的事件来决定是否需要销毁和重建UI控件。在一个UI控件销毁和重建之后，一些UI相关的数据可能会丢失。如果这些数据很小，那么可以使用onSaveInstanceState来保存。但是如果数据量很大，那么就不适合了。
#### 7.1实现一个ViewModel
架构组件提供了一个ViewModel帮助类给UI控件。这个ViewModel主要是为了提供数据给UI使用。ViewModel对象在配置变化过程中是自动保留的，所以在UI控件重建的时候可以立即使用。
#### 7.2 ViewModel的生命周期
ViewModel一直保存在内存中，直到activity finish掉或者fragment detach掉。
ViewModel一般都是在onCreate方法中初始化的
#### 7.3 在Fragments之间共享数据
#### 7.4 使用ViewModel代替Loader
### 8.Room持久层
### 9.分页库
#### 9.1 概览
使用分页库来请求和展示用户期望的数据，让用户以更经济的方式来展示这些数据。
9.1.1 库架构
分页库有一个pagedList类
9.1.2 支持多种数据架构
支持数据从数据库来，从服务器来，或者从数据库和服务器来
9.1.3 处理网络错误
9.1.4 更新现有的应用
#### 9.2 分页库的UI组件以及思考
9.2.1 链接ViewModel和UI
9.2.2 实现内容不同接口
9.2.3 使用占位符
#### 9.3 分页库的数据组件以及思考
9.3.1 创建Observable列表
9.3.2 定义你自己的分页配置
9.3.3 选择正确的数据源类型
9.3.4 数据失效的时候通知
9.3.5 建立自己的数据源
9.3.6 考虑如何更新内容
9.3.7 提供数据表达映射
### 导航架构组件
